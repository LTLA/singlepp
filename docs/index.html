<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>singlepp: C++ port of SingleR</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">singlepp
   </div>
   <div id="projectbrief">A C++ library for cell type classification</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">C++ port of SingleR </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2github_2workspace_2README"></a> </p><h1>Overview</h1>
<p>This repository contains a C++ port of the <a href="https://bioconductor.org/packages/SingleR"><b>SingleR</b></a> R package for automated cell type annotation. It primarily focuses on the prediction step given a set of references; the preparation of the references themselves is left to the user (see below). The library contains methods for simple and multi-reference predictions, returning scores and labels for each cell in the test dataset. Each cell is treated independently so the entire process is trivially parallelizable.</p>
<h1>Quick start</h1>
<p><b>singlepp</b> is a header-only library, so it can be easily used by just <code>#include</code>ing the relevant source files. Assuming the reference matrix, labels and markers are available, we can easily run the classification:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="singlepp_8hpp.html">singlepp/singlepp.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prepare the reference matrix as a tatami::NumericMatrix.</span></div>
<div class="line">ref_mat;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prepare a vector of labels, one per column of ref_mat.</span></div>
<div class="line">ref_labels;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prepare a vector of vectors of marker rankings.</span></div>
<div class="line">ref_markers;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Running the classification on a test matrix.</span></div>
<div class="line"><a class="code hl_class" href="classsinglepp_1_1Classifier.html">singlepp::Classifier</a> runner;</div>
<div class="line"><span class="keyword">auto</span> res = runner.<a class="code hl_function" href="classsinglepp_1_1Classifier.html#ac9820063ea590a345ca82bb6919289d6">run</a>(test_mat.get(), ref_mat.get(), ref_labels.data(), ref_markers);</div>
<div class="ttc" id="aclasssinglepp_1_1Classifier_html"><div class="ttname"><a href="classsinglepp_1_1Classifier.html">singlepp::Classifier</a></div><div class="ttdoc">Automatically assign cell type labels based on an expression matrix.</div><div class="ttdef"><b>Definition</b> Classifier.hpp:53</div></div>
<div class="ttc" id="aclasssinglepp_1_1Classifier_html_ac9820063ea590a345ca82bb6919289d6"><div class="ttname"><a href="classsinglepp_1_1Classifier.html#ac9820063ea590a345ca82bb6919289d6">singlepp::Classifier::run</a></div><div class="ttdeci">void run(const tatami::Matrix&lt; double, int &gt; *mat, const tatami::Matrix&lt; double, int &gt; *ref, const int *labels, Markers markers, int *best, std::vector&lt; double * &gt; &amp;scores, double *delta) const</div><div class="ttdef"><b>Definition</b> Classifier.hpp:221</div></div>
<div class="ttc" id="asinglepp_8hpp_html"><div class="ttname"><a href="singlepp_8hpp.html">singlepp.hpp</a></div><div class="ttdoc">Umbrella header for all includes.</div></div>
</div><!-- fragment --><p>This returns an object containing the scores and predicted label for each cell in the test matrix. Users can also supply their own arrays to be filled with the results:</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; assignments(ncells);</div>
<div class="line">std::vector&lt;std::vector&lt;double&gt; &gt; scores(nlabels, std::vector&lt;double&gt;(ncells));</div>
<div class="line">std::vector&lt;const double*&gt; score_ptrs(nlabels);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> l = 0; l &lt; nlabels; ++l) {</div>
<div class="line">    score_ptrs[l] = scores[l].data();</div>
<div class="line">}</div>
<div class="line">std::vector&lt;double&gt; delta(ncells);</div>
<div class="line"> </div>
<div class="line">runner.<a class="code hl_function" href="classsinglepp_1_1Classifier.html#ac9820063ea590a345ca82bb6919289d6">run</a>(</div>
<div class="line">    test_mat.get(),</div>
<div class="line">    ref_mat.get(), </div>
<div class="line">    ref_labels.data(), </div>
<div class="line">    ref_markers,</div>
<div class="line">    assignments.data(),</div>
<div class="line">    score_ptrs,</div>
<div class="line">    delta.data()</div>
<div class="line">);</div>
</div><!-- fragment --><p>See the <a href="https://ltla.github.io/singlepp">reference documentation</a> for more details.</p>
<h1>Preparing references</h1>
<p>A reference dataset should have at least three components:</p>
<ul>
<li>The "expression" matrix, where rows are features and columns are reference profiles. Only the rank of the expression values are used by <b>singlepp</b>, so one could apply any transformation that preserves the ranks.</li>
<li>A vector of length equal to the number of columns of the matrix, containing the label for each reference profile. These labels should be integers from <code>[0, N)</code> where <code>N</code> is the number of unique labels.</li>
<li>A vector of vector of integer vectors, containing the ranked marker genes from pairwise comparisons between labels. Say that <code>y</code> is this object, then <code>y[i][j][k]</code> should contain the <code>k</code>-th best marker gene that is upregulated in label <code>i</code> compared to label <code>j</code>. Marker genes should be reported as row indices of the expression matrix.</li>
</ul>
<p>In practical usage, they will also contain:</p>
<ul>
<li>Feature names for each row of the expression matrix. This can be used by <b>singlepp</b> to match to the features of the test matrix, if the feature sets are not the same.</li>
<li>Label names, to map the integer labels to something that is meaningful to the user. This is not used by <b>singlepp</b> itself, which only deals with the integers.</li>
</ul>
<p>See <a href="https://github.com/clusterfork/singlepp-references">here</a> for some references that have been formatted in this manner.</p>
<h1>Intersecting feature sets</h1>
<p>Often the reference dataset will not have the same features as the test dataset. To handle this case, users can provide identifiers for the rows of the reference and test matrices. <b>singlepp</b> will then perform classification using the intersection of features.</p>
<div class="fragment"><div class="line">test_names; <span class="comment">// vector of feature names of the test data</span></div>
<div class="line">ref_names; <span class="comment">// vector of feature names of the reference data</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res = runner.<a class="code hl_function" href="classsinglepp_1_1Classifier.html#ac9820063ea590a345ca82bb6919289d6">run</a>(</div>
<div class="line">    test_mat.get(),</div>
<div class="line">    test_names.data(),</div>
<div class="line">    ref_mat.get(), </div>
<div class="line">    ref_names.data(),</div>
<div class="line">    ref_labels.data(), </div>
<div class="line">    ref_markers</div>
<div class="line">);</div>
</div><!-- fragment --><p>The identifiers can be anything that can be hashed and compared. These are most commonly <code>std::string</code>s.</p>
<h1>Prebuilding the references</h1>
<p>For repeated classification with the same reference, advanced users can call <code>build()</code> before <code>run()</code>. This ensures that the reference set-up cost is only paid once.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> pre = runner.build(ref_mat.get(), ref_labels.data(), ref_markers);</div>
<div class="line"><span class="keyword">auto</span> res = runner.<a class="code hl_function" href="classsinglepp_1_1Classifier.html#ac9820063ea590a345ca82bb6919289d6">run</a>(test_mat.get(), pre);</div>
</div><!-- fragment --><p>The same approach works when considering an intersection of features, assuming that all test matrices have the same order of features as in the <code>test_names</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> pre2 = runner.build(</div>
<div class="line">    test_names.size(), </div>
<div class="line">    test_names.data(),</div>
<div class="line">    ref_mat.get(), </div>
<div class="line">    ref_names.data(),</div>
<div class="line">    ref_labels.data(), </div>
<div class="line">    ref_markers</div>
<div class="line">);</div>
<div class="line"><span class="keyword">auto</span> res2 = runner.<a class="code hl_function" href="classsinglepp_1_1Classifier.html#ac9820063ea590a345ca82bb6919289d6">run</a>(test_mat.get(), pre);</div>
</div><!-- fragment --><h1>Integrating results across references</h1>
<p>To combine results from multiple references, we first need to perform classification within each reference using the <code>build()</code> + <code>run()</code> approach. Let's say we have two references A and B:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> preA = runner.build(refA_mat.get(), refA_labels.data(), refA_markers);</div>
<div class="line"><span class="keyword">auto</span> resA = runner.<a class="code hl_function" href="classsinglepp_1_1Classifier.html#ac9820063ea590a345ca82bb6919289d6">run</a>(test_mat.get(), preA);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> preB = runner.build(refB_mat.get(), refB_labels.data(), refB_markers);</div>
<div class="line"><span class="keyword">auto</span> resB = runner.<a class="code hl_function" href="classsinglepp_1_1Classifier.html#ac9820063ea590a345ca82bb6919289d6">run</a>(test_mat.get(), preB);</div>
</div><!-- fragment --><p>We build the integrated references:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsinglepp_1_1IntegratedBuilder.html">singlepp::IntegratedBuilder</a> ibuilder;</div>
<div class="line">ibuilder.<a class="code hl_function" href="classsinglepp_1_1IntegratedBuilder.html#a7f3c49224a66c3e9ed5bdd1c140f03aa">add</a>(refA_mat.get(), refA_labels.data(), preA);</div>
<div class="line">ibuilder.<a class="code hl_function" href="classsinglepp_1_1IntegratedBuilder.html#a7f3c49224a66c3e9ed5bdd1c140f03aa">add</a>(refB_mat.get(), refB_labels.data(), preB);</div>
<div class="line"><span class="keyword">auto</span> irefs = ibuilder.<a class="code hl_function" href="classsinglepp_1_1IntegratedBuilder.html#a07b59ff274e8fa87ddc0443896fff8f3">finish</a>();</div>
<div class="ttc" id="aclasssinglepp_1_1IntegratedBuilder_html"><div class="ttname"><a href="classsinglepp_1_1IntegratedBuilder.html">singlepp::IntegratedBuilder</a></div><div class="ttdoc">Factory to prepare multiple references for integrated classification.</div><div class="ttdef"><b>Definition</b> IntegratedBuilder.hpp:87</div></div>
<div class="ttc" id="aclasssinglepp_1_1IntegratedBuilder_html_a07b59ff274e8fa87ddc0443896fff8f3"><div class="ttname"><a href="classsinglepp_1_1IntegratedBuilder.html#a07b59ff274e8fa87ddc0443896fff8f3">singlepp::IntegratedBuilder::finish</a></div><div class="ttdeci">IntegratedReferences finish()</div><div class="ttdef"><b>Definition</b> IntegratedBuilder.hpp:512</div></div>
<div class="ttc" id="aclasssinglepp_1_1IntegratedBuilder_html_a7f3c49224a66c3e9ed5bdd1c140f03aa"><div class="ttname"><a href="classsinglepp_1_1IntegratedBuilder.html#a7f3c49224a66c3e9ed5bdd1c140f03aa">singlepp::IntegratedBuilder::add</a></div><div class="ttdeci">void add(const tatami::Matrix&lt; double, int &gt; *ref, const int *labels, const Markers &amp;markers)</div><div class="ttdef"><b>Definition</b> IntegratedBuilder.hpp:227</div></div>
</div><!-- fragment --><p>And then we can finally run the scoring:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsinglepp_1_1IntegratedScorer.html">singlepp::IntegratedScorer</a> iscorer;</div>
<div class="line"><span class="keyword">auto</span> ires = iscorer.<a class="code hl_function" href="classsinglepp_1_1IntegratedScorer.html#a654120c9074b8106cfa11052ee7fdb03">run</a>(test_mat.get(), irefs);</div>
<div class="ttc" id="aclasssinglepp_1_1IntegratedScorer_html"><div class="ttname"><a href="classsinglepp_1_1IntegratedScorer.html">singlepp::IntegratedScorer</a></div><div class="ttdoc">Integrate classifications from multiple references.</div><div class="ttdef"><b>Definition</b> IntegratedScorer.hpp:52</div></div>
<div class="ttc" id="aclasssinglepp_1_1IntegratedScorer_html_a654120c9074b8106cfa11052ee7fdb03"><div class="ttname"><a href="classsinglepp_1_1IntegratedScorer.html#a654120c9074b8106cfa11052ee7fdb03">singlepp::IntegratedScorer::run</a></div><div class="ttdeci">void run(const tatami::Matrix&lt; double, int &gt; *mat, const std::vector&lt; const int * &gt; &amp;assigned, const IntegratedReferences &amp;built, int *best, std::vector&lt; double * &gt; &amp;scores, double *delta) const</div><div class="ttdef"><b>Definition</b> IntegratedScorer.hpp:195</div></div>
</div><!-- fragment --><h1>Building projects</h1>
<p>If you're using CMake, you just need to add something like this to your <code>CMakeLists.txt</code>:</p>
<div class="fragment"><div class="line">include(FetchContent)</div>
<div class="line"> </div>
<div class="line">FetchContent_Declare(</div>
<div class="line">  kmeans </div>
<div class="line">  GIT_REPOSITORY https://github.com/LTLA/singlepp</div>
<div class="line">  GIT_TAG master # or any version of interest</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">FetchContent_MakeAvailable(singlepp)</div>
</div><!-- fragment --><p>Then you can link to <b>singlepp</b> to make the headers available during compilation:</p>
<div class="fragment"><div class="line"># For executables:</div>
<div class="line">target_link_libraries(myexe singlepp)</div>
<div class="line"> </div>
<div class="line"># For libaries</div>
<div class="line">target_link_libraries(mylib INTERFACE singlepp)</div>
</div><!-- fragment --><h1>References</h1>
<p>Aran D et al. (2019). Reference-based analysis of lung single-cell sequencing reveals a transitional profibrotic macrophage. <em>Nat. Immunol.</em> 20, 163-172 </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
