<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>singlepp: singlepp::Classifier Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">singlepp
   </div>
   <div id="projectbrief">A C++ library for cell type classification</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesinglepp.html">singlepp</a></li><li class="navelem"><a class="el" href="classsinglepp_1_1Classifier.html">Classifier</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsinglepp_1_1Classifier-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">singlepp::Classifier Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Automatically assign cell type labels based on an expression matrix.  
 <a href="classsinglepp_1_1Classifier.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Classifier_8hpp_source.html">Classifier.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsinglepp_1_1Classifier_1_1Defaults.html">Defaults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parameters for annotation.  <a href="structsinglepp_1_1Classifier_1_1Defaults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8da2466b32076a34b038d0bb88282ae1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsinglepp_1_1Classifier.html">Classifier</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1Classifier.html#a8da2466b32076a34b038d0bb88282ae1">set_quantile</a> (double q=<a class="el" href="structsinglepp_1_1Classifier_1_1Defaults.html#aa2b02289250da4ff08f1106a23850e14">Defaults::quantile</a>)</td></tr>
<tr class="separator:a8da2466b32076a34b038d0bb88282ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5cc599c01248cd5e14508a4b0ec0e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsinglepp_1_1Classifier.html">Classifier</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1Classifier.html#a2a5cc599c01248cd5e14508a4b0ec0e5">set_fine_tune_threshold</a> (double t=<a class="el" href="structsinglepp_1_1Classifier_1_1Defaults.html#a6aa039661082457df6b283e38e696d67">Defaults::fine_tune_threshold</a>)</td></tr>
<tr class="separator:a2a5cc599c01248cd5e14508a4b0ec0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed20bfa64b9dd557f38b665116e8005a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsinglepp_1_1Classifier.html">Classifier</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1Classifier.html#aed20bfa64b9dd557f38b665116e8005a">set_fine_tune</a> (bool f=<a class="el" href="structsinglepp_1_1Classifier_1_1Defaults.html#aa1690105051ae24ec10dc0b78c62bed3">Defaults::fine_tune</a>)</td></tr>
<tr class="separator:aed20bfa64b9dd557f38b665116e8005a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5406afbfe172ec57062f803d26c45f83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsinglepp_1_1Classifier.html">Classifier</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1Classifier.html#a5406afbfe172ec57062f803d26c45f83">set_top</a> (int t=<a class="el" href="structsinglepp_1_1Classifier_1_1Defaults.html#ac64a5e435923d56229cfc371861ffaa5">Defaults::top</a>)</td></tr>
<tr class="separator:a5406afbfe172ec57062f803d26c45f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7460114bf15720c699327f0f51d462da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsinglepp_1_1Classifier.html">Classifier</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1Classifier.html#a7460114bf15720c699327f0f51d462da">set_approximate</a> (bool a=<a class="el" href="structsinglepp_1_1Classifier_1_1Defaults.html#aa8668abed146d071d16b47f45d99413c">Defaults::approximate</a>)</td></tr>
<tr class="separator:a7460114bf15720c699327f0f51d462da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8aa9bca868ccf47f32f4a5bdb4e0c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsinglepp_1_1Classifier.html">Classifier</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1Classifier.html#a7e8aa9bca868ccf47f32f4a5bdb4e0c9">set_num_threads</a> (int n=<a class="el" href="structsinglepp_1_1Classifier_1_1Defaults.html#a859001ec70b051bfaa3638c58c64952f">Defaults::num_threads</a>)</td></tr>
<tr class="separator:a7e8aa9bca868ccf47f32f4a5bdb4e0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9820063ea590a345ca82bb6919289d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1Classifier.html#ac9820063ea590a345ca82bb6919289d6">run</a> (const tatami::Matrix&lt; double, int &gt; *mat, const tatami::Matrix&lt; double, int &gt; *ref, const int *labels, <a class="el" href="namespacesinglepp.html#ae39cf61993000d182cb3464b4ace1406">Markers</a> markers, int *best, std::vector&lt; double * &gt; &amp;scores, double *delta) const</td></tr>
<tr class="separator:ac9820063ea590a345ca82bb6919289d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b0f91b18f991c8fc0197cb5d51aa91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsinglepp_1_1BasicScorer_1_1Results.html">BasicScorer::Results</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1Classifier.html#a30b0f91b18f991c8fc0197cb5d51aa91">run</a> (const tatami::Matrix&lt; double, int &gt; *mat, const tatami::Matrix&lt; double, int &gt; *ref, const int *labels, <a class="el" href="namespacesinglepp.html#ae39cf61993000d182cb3464b4ace1406">Markers</a> markers) const</td></tr>
<tr class="separator:a30b0f91b18f991c8fc0197cb5d51aa91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4a77e384f1e3d7e143420d1a5e81c7"><td class="memTemplParams" colspan="2">template&lt;class Id &gt; </td></tr>
<tr class="memitem:abb4a77e384f1e3d7e143420d1a5e81c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1Classifier.html#abb4a77e384f1e3d7e143420d1a5e81c7">run</a> (const tatami::Matrix&lt; double, int &gt; *mat, const Id *mat_id, const tatami::Matrix&lt; double, int &gt; *ref, const Id *ref_id, const int *labels, <a class="el" href="namespacesinglepp.html#ae39cf61993000d182cb3464b4ace1406">Markers</a> markers, int *best, std::vector&lt; double * &gt; &amp;scores, double *delta) const</td></tr>
<tr class="separator:abb4a77e384f1e3d7e143420d1a5e81c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefccb8ec487ddc43c4a7cd7786657c68"><td class="memTemplParams" colspan="2">template&lt;class Id &gt; </td></tr>
<tr class="memitem:aefccb8ec487ddc43c4a7cd7786657c68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsinglepp_1_1BasicScorer_1_1Results.html">BasicScorer::Results</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1Classifier.html#aefccb8ec487ddc43c4a7cd7786657c68">run</a> (const tatami::Matrix&lt; double, int &gt; *mat, const Id *mat_id, const tatami::Matrix&lt; double, int &gt; *ref, const Id *ref_id, const int *labels, <a class="el" href="namespacesinglepp.html#ae39cf61993000d182cb3464b4ace1406">Markers</a> markers) const</td></tr>
<tr class="separator:aefccb8ec487ddc43c4a7cd7786657c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Automatically assign cell type labels based on an expression matrix. </p>
<p >This implements the <a href="https://bioconductor.org/packages/SingleR"><b>SingleR</b></a> algorithm for automated annotation of single-cell RNA-seq data. For each cell, we compute the Spearman rank correlation between that cell and the reference expression profiles. This is done using only the subset of genes that are label-specific markers, most typically the top genes from pairwise comparisons between each label's expression profiles. For each label, we take the correlations involving that label's reference profiles and convert it into a score. The label with the highest score is used as an initial label for that cell.</p>
<p >For each cell, we apply fine-tuning iterations to improve the label accuracy by refining the feature space. At each iteration, we find the subset of labels with scores that are close to the maximum score according to some threshold. We recompute the scores based on the markers for this label subset, and we repeat the process until only one label is left in the subset or the subset is unchanged. At the end of the iterations, the label with the highest score (or the only label, if just one is left) is used as the label for the cell. This process aims to remove noise by eliminating irrelevant genes when attempting to distinguish closely related labels.</p>
<p >Each label's score is defined as a user-specified quantile of the distribution of correlations across all reference profiles assigned to that label. (We typically consider a large quantile, e.g., the 80% percentile of the correlations.) The use of a quantile avoids problems with differences in the number of reference profiles per label; in contrast, just using the "top X correlations" would implicitly favor labels with more reference profiles.</p>
<p >The choice of Spearman's correlation provides some robustness against batch effects when comparing reference and test datasets. Only the relative expression <em>within</em> each cell needs to be comparable, not their relative expression across cells. As a result, it does not matter whether raw counts are supplied or log-transformed expression values, as the latter is a monotonic transformation of the latter (within each cell). The algorithm is also robust to differences in technologies between reference and test profiles, though it is preferable to have like-for-like comparisons.</p>
<dl class="section see"><dt>See also</dt><dd>Aran D et al. (2019). Reference-based analysis of lung single-cell sequencing reveals a transitional profibrotic macrophage. <em>Nat. Immunol.</em> 20, 163-172 </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aefccb8ec487ddc43c4a7cd7786657c68" name="aefccb8ec487ddc43c4a7cd7786657c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefccb8ec487ddc43c4a7cd7786657c68">&#9670;&nbsp;</a></span>run() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Id &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsinglepp_1_1BasicScorer_1_1Results.html">BasicScorer::Results</a> singlepp::Classifier::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; double, int &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Id *&#160;</td>
          <td class="paramname"><em>mat_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tatami::Matrix&lt; double, int &gt; *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Id *&#160;</td>
          <td class="paramname"><em>ref_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesinglepp.html#ae39cf61993000d182cb3464b4ace1406">Markers</a>&#160;</td>
          <td class="paramname"><em>markers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Id</td><td>Gene identifier for each row.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mat</td><td>Expression matrix of the test dataset, where rows are genes and columns are cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_id</td><td>Pointer to an array of identifiers of length equal to the number of rows of <code>mat</code>. This should contain a unique identifier for each row of <code>mat</code> (typically a gene name or index). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ref</td><td>An expression matrix for the reference expression profiles, where rows are genes and columns are cells. This should have non-zero columns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ref_id</td><td>Pointer to an array of identifiers of length equal to the number of rows of any <code>ref</code>. This should contain a unique identifier for each row in <code>ref</code>, and should be comparable to <code>mat_id</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">labels</td><td>An array of length equal to the number of columns of <code>ref</code>, containing the label for each sample. The smallest label should be 0 and the largest label should be equal to the total number of unique labels minus 1. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">markers</td><td>A vector of vectors of ranked marker genes for each pairwise comparison between labels, see <code>Markers</code> for more details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structsinglepp_1_1BasicScorer_1_1Results.html" title="Automated classification results.">BasicScorer::Results</a></code> object containing the assigned labels and scores. </dd></dl>

</div>
</div>
<a id="abb4a77e384f1e3d7e143420d1a5e81c7" name="abb4a77e384f1e3d7e143420d1a5e81c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4a77e384f1e3d7e143420d1a5e81c7">&#9670;&nbsp;</a></span>run() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Id &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void singlepp::Classifier::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; double, int &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Id *&#160;</td>
          <td class="paramname"><em>mat_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tatami::Matrix&lt; double, int &gt; *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Id *&#160;</td>
          <td class="paramname"><em>ref_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesinglepp.html#ae39cf61993000d182cb3464b4ace1406">Markers</a>&#160;</td>
          <td class="paramname"><em>markers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>best</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double * &gt; &amp;&#160;</td>
          <td class="paramname"><em>scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Id</td><td>Gene identifier for each row.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mat</td><td>Expression matrix of the test dataset, where rows are genes and columns are cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_id</td><td>Pointer to an array of identifiers of length equal to the number of rows of <code>mat</code>. This should contain a unique identifier for each row of <code>mat</code> (typically a gene name or index). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ref</td><td>An expression matrix for the reference expression profiles, where rows are genes and columns are cells. This should have non-zero columns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ref_id</td><td>Pointer to an array of identifiers of length equal to the number of rows of any <code>ref</code>. This should contain a unique identifier for each row in <code>ref</code>, and should be comparable to <code>mat_id</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">labels</td><td>An array of length equal to the number of columns of <code>ref</code>, containing the label for each sample. The smallest label should be 0 and the largest label should be equal to the total number of unique labels minus 1. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">markers</td><td>A vector of vectors of ranked marker genes for each pairwise comparison between labels, see <code>Markers</code> for more details. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">best</td><td>Pointer to an array of length equal to the number of columns in <code>mat</code>. This is filled with the index of the assigned label for each cell. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">scores</td><td>Vector of pointers of length equal to the number of labels. Each pointer should point to an array of length equal to the number of columns in <code>mat</code>. This is filled with the (non-fine-tuned) score for that label for each cell. Any pointer may be <code>NULL</code> in which case the scores for that label will not be saved. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">delta</td><td>Pointer to an array of length equal to the number of columns in <code>mat</code>. This is filled with the difference between the highest and second-highest scores, possibly after fine-tuning. This may also be <code>NULL</code> in which case the deltas are not reported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>best</code>, <code>scores</code> and <code>delta</code> are filled with their output values.</dd></dl>
<p>This version of <code><a class="el" href="classsinglepp_1_1Classifier.html#ac9820063ea590a345ca82bb6919289d6">run()</a></code> applies an intersection to find the common genes between <code>mat</code> and <code>ref</code>, based on their shared values in <code>mat_id</code> and <code>ref_id</code>. The annotation is then performed using only the subset of common genes. The aim is to easily accommodate differences in feature annotation between the test and reference profiles. </p>

</div>
</div>
<a id="a30b0f91b18f991c8fc0197cb5d51aa91" name="a30b0f91b18f991c8fc0197cb5d51aa91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b0f91b18f991c8fc0197cb5d51aa91">&#9670;&nbsp;</a></span>run() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsinglepp_1_1BasicScorer_1_1Results.html">BasicScorer::Results</a> singlepp::Classifier::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; double, int &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tatami::Matrix&lt; double, int &gt; *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesinglepp.html#ae39cf61993000d182cb3464b4ace1406">Markers</a>&#160;</td>
          <td class="paramname"><em>markers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mat</td><td>Expression matrix of the test dataset, where rows are genes and columns are cells. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ref</td><td>An expression matrix for the reference expression profiles. This should have non-zero columns and the same number of rows (i.e., genes) at <code>mat</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">labels</td><td>An array of length equal to the number of columns of <code>ref</code>, containing the label for each sample. The smallest label should be 0 and the largest label should be equal to the total number of unique labels minus 1. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">markers</td><td>A vector of vectors of ranked marker genes for each pairwise comparison between labels, see <code>Markers</code> for more details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structsinglepp_1_1BasicScorer_1_1Results.html" title="Automated classification results.">BasicScorer::Results</a></code> object containing the assigned labels and scores. </dd></dl>

</div>
</div>
<a id="ac9820063ea590a345ca82bb6919289d6" name="ac9820063ea590a345ca82bb6919289d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9820063ea590a345ca82bb6919289d6">&#9670;&nbsp;</a></span>run() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void singlepp::Classifier::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; double, int &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tatami::Matrix&lt; double, int &gt; *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesinglepp.html#ae39cf61993000d182cb3464b4ace1406">Markers</a>&#160;</td>
          <td class="paramname"><em>markers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>best</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double * &gt; &amp;&#160;</td>
          <td class="paramname"><em>scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mat</td><td>Expression matrix of the test dataset, where rows are genes and columns are cells. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ref</td><td>An expression matrix for the reference expression profiles. This should have non-zero columns and the same number of rows (i.e., genes) at <code>mat</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">labels</td><td>An array of length equal to the number of columns of <code>ref</code>, containing the label for each sample. The smallest label should be 0 and the largest label should be equal to the total number of unique labels minus 1. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">markers</td><td>A vector of vectors of ranked marker genes for each pairwise comparison between labels, see <code>Markers</code> for more details. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">best</td><td>Pointer to an array of length equal to the number of columns in <code>mat</code>. This is filled with the index of the assigned label for each cell. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">scores</td><td>Vector of pointers of length equal to the number of labels. Each pointer should point to an array of length equal to the number of columns in <code>mat</code>. This is filled with the (non-fine-tuned) score for that label for each cell. Any pointer may be <code>NULL</code> in which case the scores for that label will not be saved. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">delta</td><td>Pointer to an array of length equal to the number of columns in <code>mat</code>. This is filled with the difference between the highest and second-highest scores, possibly after fine-tuning. This may also be <code>NULL</code> in which case the deltas are not reported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>best</code>, <code>scores</code> and <code>delta</code> are filled with their output values. </dd></dl>

</div>
</div>
<a id="a7460114bf15720c699327f0f51d462da" name="a7460114bf15720c699327f0f51d462da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7460114bf15720c699327f0f51d462da">&#9670;&nbsp;</a></span>set_approximate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinglepp_1_1Classifier.html">Classifier</a> &amp; singlepp::Classifier::set_approximate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="structsinglepp_1_1Classifier_1_1Defaults.html#aa8668abed146d071d16b47f45d99413c">Defaults::approximate</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Whether to use an approximate method to quickly find the quantile. This sacrifices some accuracy for speed when labels have many reference profiles.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classsinglepp_1_1Classifier.html" title="Automatically assign cell type labels based on an expression matrix.">Classifier</a></code> object. </dd></dl>

</div>
</div>
<a id="aed20bfa64b9dd557f38b665116e8005a" name="aed20bfa64b9dd557f38b665116e8005a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed20bfa64b9dd557f38b665116e8005a">&#9670;&nbsp;</a></span>set_fine_tune()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinglepp_1_1Classifier.html">Classifier</a> &amp; singlepp::Classifier::set_fine_tune </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="structsinglepp_1_1Classifier_1_1Defaults.html#aa1690105051ae24ec10dc0b78c62bed3">Defaults::fine_tune</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Whether to perform fine-tuning. This can be disabled to improve speed at the cost of accuracy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classsinglepp_1_1Classifier.html" title="Automatically assign cell type labels based on an expression matrix.">Classifier</a></code> object. </dd></dl>

</div>
</div>
<a id="a2a5cc599c01248cd5e14508a4b0ec0e5" name="a2a5cc599c01248cd5e14508a4b0ec0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5cc599c01248cd5e14508a4b0ec0e5">&#9670;&nbsp;</a></span>set_fine_tune_threshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinglepp_1_1Classifier.html">Classifier</a> &amp; singlepp::Classifier::set_fine_tune_threshold </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="structsinglepp_1_1Classifier_1_1Defaults.html#a6aa039661082457df6b283e38e696d67">Defaults::fine_tune_threshold</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Threshold to use to select the top-scoring subset of labels during fine-tuning. Larger values increase the chance of recovering the correct label at the cost of computational time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classsinglepp_1_1Classifier.html" title="Automatically assign cell type labels based on an expression matrix.">Classifier</a></code> object.</dd></dl>
<p>Needless to say, one should not set <code>t</code> to a value that is too large. Otherwise, the first fine-tuning iteration would just contain all labels and there would be no reduction of the marker space. </p>

</div>
</div>
<a id="a7e8aa9bca868ccf47f32f4a5bdb4e0c9" name="a7e8aa9bca868ccf47f32f4a5bdb4e0c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8aa9bca868ccf47f32f4a5bdb4e0c9">&#9670;&nbsp;</a></span>set_num_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinglepp_1_1Classifier.html">Classifier</a> &amp; singlepp::Classifier::set_num_threads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structsinglepp_1_1Classifier_1_1Defaults.html#a859001ec70b051bfaa3638c58c64952f">Defaults::num_threads</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classsinglepp_1_1Classifier.html" title="Automatically assign cell type labels based on an expression matrix.">Classifier</a></code> object. </dd></dl>

</div>
</div>
<a id="a8da2466b32076a34b038d0bb88282ae1" name="a8da2466b32076a34b038d0bb88282ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da2466b32076a34b038d0bb88282ae1">&#9670;&nbsp;</a></span>set_quantile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinglepp_1_1Classifier.html">Classifier</a> &amp; singlepp::Classifier::set_quantile </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="structsinglepp_1_1Classifier_1_1Defaults.html#aa2b02289250da4ff08f1106a23850e14">Defaults::quantile</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Quantile to use to compute a per-label score from the correlations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classsinglepp_1_1Classifier.html" title="Automatically assign cell type labels based on an expression matrix.">Classifier</a></code> object.</dd></dl>
<p>Values of <code>q</code> closer to 0.5 focus on the behavior of the majority of a label's reference profiles. Smaller values will be more sensitive to the presence of a subset of profiles that are more similar to the test cell, which can be useful when the reference profiles themselves are heterogeneous. </p>

</div>
</div>
<a id="a5406afbfe172ec57062f803d26c45f83" name="a5406afbfe172ec57062f803d26c45f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5406afbfe172ec57062f803d26c45f83">&#9670;&nbsp;</a></span>set_top()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinglepp_1_1Classifier.html">Classifier</a> &amp; singlepp::Classifier::set_top </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="structsinglepp_1_1Classifier_1_1Defaults.html#ac64a5e435923d56229cfc371861ffaa5">Defaults::top</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Number of top markers to use from each pairwise comparison between labels. Larger values improve the stability of the correlations at the cost of increasing noise and computational work.</td></tr>
  </table>
  </dd>
</dl>
<p>Setting it to a negative value will instruct <code><a class="el" href="classsinglepp_1_1Classifier.html#ac9820063ea590a345ca82bb6919289d6">run()</a></code> to use all supplied markers. This is useful in situations where the supplied markers have already been curated.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classsinglepp_1_1Classifier.html" title="Automatically assign cell type labels based on an expression matrix.">Classifier</a></code> object. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>singlepp/<a class="el" href="Classifier_8hpp_source.html">Classifier.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
