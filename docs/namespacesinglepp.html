<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>singlepp: singlepp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">singlepp
   </div>
   <div id="projectbrief">A C++ library for cell type classification</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">singlepp Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1BasicBuilder.html">BasicBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a single pre-built reference for further classification.  <a href="classsinglepp_1_1BasicBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1BasicScorer.html">BasicScorer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classify cells from a single pre-built reference dataset.  <a href="classsinglepp_1_1BasicScorer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1ChooseClassicMarkers.html">ChooseClassicMarkers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classic method for choosing markers.  <a href="classsinglepp_1_1ChooseClassicMarkers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1Classifier.html">Classifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically assign cell type labels based on an expression matrix.  <a href="classsinglepp_1_1Classifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1IntegratedBuilder.html">IntegratedBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to prepare multiple references for integrated classification.  <a href="classsinglepp_1_1IntegratedBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsinglepp_1_1IntegratedReferences.html">IntegratedReferences</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference datasets prepared for integrated classification.  <a href="structsinglepp_1_1IntegratedReferences.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1IntegratedScorer.html">IntegratedScorer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate classifications from multiple references.  <a href="classsinglepp_1_1IntegratedScorer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae39cf61993000d182cb3464b4ace1406"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; std::vector&lt; std::vector&lt; int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesinglepp.html#ae39cf61993000d182cb3464b4ace1406">Markers</a></td></tr>
<tr class="separator:ae39cf61993000d182cb3464b4ace1406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6460d8cbafda27b6b4a9f5eb969760"><td class="memTemplParams" colspan="2">template&lt;typename Data  = double, typename Index  = int&gt; </td></tr>
<tr class="memitem:a3b6460d8cbafda27b6b4a9f5eb969760"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinglepp.html#a3b6460d8cbafda27b6b4a9f5eb969760">RankMatrix</a> = tatami::DenseColumnMatrix&lt; Data, Index, std::vector&lt; int &gt; &gt;</td></tr>
<tr class="separator:a3b6460d8cbafda27b6b4a9f5eb969760"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac9e38562b296cc7c7d7682f194514634"><td class="memTemplParams" colspan="2">template&lt;bool parallel_ = false&gt; </td></tr>
<tr class="memitem:ac9e38562b296cc7c7d7682f194514634"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinglepp.html#ac9e38562b296cc7c7d7682f194514634">load_labels_from_text_file</a> (const char *path, size_t buffer_size=65536)</td></tr>
<tr class="separator:ac9e38562b296cc7c7d7682f194514634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58095c8ccda647564410c6ee33bad6f1"><td class="memTemplParams" colspan="2">template&lt;bool parallel_ = false&gt; </td></tr>
<tr class="memitem:a58095c8ccda647564410c6ee33bad6f1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinglepp.html#a58095c8ccda647564410c6ee33bad6f1">load_labels_from_gzip_file</a> (const char *path, size_t buffer_size=65536)</td></tr>
<tr class="separator:a58095c8ccda647564410c6ee33bad6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c5cb9cae30f6db572de03a143c9e06"><td class="memTemplParams" colspan="2">template&lt;bool parallel_ = false&gt; </td></tr>
<tr class="memitem:a74c5cb9cae30f6db572de03a143c9e06"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinglepp.html#a74c5cb9cae30f6db572de03a143c9e06">load_labels_from_zlib_buffer</a> (const unsigned char *buffer, size_t len, size_t buffer_size=65536)</td></tr>
<tr class="separator:a74c5cb9cae30f6db572de03a143c9e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77a7375b1acb5785ae37080297ece71"><td class="memTemplParams" colspan="2">template&lt;bool parallel_ = false&gt; </td></tr>
<tr class="memitem:aa77a7375b1acb5785ae37080297ece71"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinglepp.html#aa77a7375b1acb5785ae37080297ece71">load_label_names_from_text_file</a> (const char *path, size_t buffer_size=65536)</td></tr>
<tr class="separator:aa77a7375b1acb5785ae37080297ece71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11981bf2415263c3af3537aa715f530f"><td class="memTemplParams" colspan="2">template&lt;bool parallel_ = false&gt; </td></tr>
<tr class="memitem:a11981bf2415263c3af3537aa715f530f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinglepp.html#a11981bf2415263c3af3537aa715f530f">load_label_names_from_gzip_file</a> (const char *path, size_t buffer_size=65536)</td></tr>
<tr class="separator:a11981bf2415263c3af3537aa715f530f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a79b526b73debbf3de4931e4ca9d2e"><td class="memTemplParams" colspan="2">template&lt;bool parallel_ = false&gt; </td></tr>
<tr class="memitem:ae0a79b526b73debbf3de4931e4ca9d2e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinglepp.html#ae0a79b526b73debbf3de4931e4ca9d2e">load_label_names_from_zlib_buffer</a> (const unsigned char *buffer, size_t len, size_t buffer_size=65536)</td></tr>
<tr class="separator:ae0a79b526b73debbf3de4931e4ca9d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39179283e07be40a5682e295bd8ffa8"><td class="memTemplParams" colspan="2">template&lt;bool parallel_ = false&gt; </td></tr>
<tr class="memitem:ad39179283e07be40a5682e295bd8ffa8"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::string &gt;, std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinglepp.html#ad39179283e07be40a5682e295bd8ffa8">load_features_from_text_file</a> (const char *path, size_t buffer_size=65536)</td></tr>
<tr class="separator:ad39179283e07be40a5682e295bd8ffa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586796abc2b9fee9a5e6164e2a941a0c"><td class="memTemplParams" colspan="2">template&lt;bool parallel_ = false&gt; </td></tr>
<tr class="memitem:a586796abc2b9fee9a5e6164e2a941a0c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::string &gt;, std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinglepp.html#a586796abc2b9fee9a5e6164e2a941a0c">load_features_from_gzip_file</a> (const char *path, size_t buffer_size=65536)</td></tr>
<tr class="separator:a586796abc2b9fee9a5e6164e2a941a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49896d2aadb5a23391a38ac2aee4436e"><td class="memTemplParams" colspan="2">template&lt;bool parallel_ = false&gt; </td></tr>
<tr class="memitem:a49896d2aadb5a23391a38ac2aee4436e"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::string &gt;, std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinglepp.html#a49896d2aadb5a23391a38ac2aee4436e">load_features_from_zlib_buffer</a> (const unsigned char *buffer, size_t len, size_t buffer_size=65536)</td></tr>
<tr class="separator:a49896d2aadb5a23391a38ac2aee4436e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01271d95d083bd7d3f1c3b26e9febe18"><td class="memTemplParams" colspan="2">template&lt;typename Data  = double, typename Index  = int, bool parallel_ = false&gt; </td></tr>
<tr class="memitem:a01271d95d083bd7d3f1c3b26e9febe18"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesinglepp.html#a3b6460d8cbafda27b6b4a9f5eb969760">RankMatrix</a>&lt; Data, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinglepp.html#a01271d95d083bd7d3f1c3b26e9febe18">load_rankings_from_text_file</a> (const char *path, size_t buffer_size=65536)</td></tr>
<tr class="separator:a01271d95d083bd7d3f1c3b26e9febe18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e53df2a196132201f5de886c066959c"><td class="memTemplParams" colspan="2">template&lt;typename Data  = double, typename Index  = int, bool parallel_ = false&gt; </td></tr>
<tr class="memitem:a7e53df2a196132201f5de886c066959c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesinglepp.html#a3b6460d8cbafda27b6b4a9f5eb969760">RankMatrix</a>&lt; Data, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinglepp.html#a7e53df2a196132201f5de886c066959c">load_rankings_from_gzip_file</a> (const char *path, size_t buffer_size=65536)</td></tr>
<tr class="separator:a7e53df2a196132201f5de886c066959c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f1d95625ad9468a29b03c5e3cee0e4"><td class="memTemplParams" colspan="2">template&lt;typename Data  = double, typename Index  = int, bool parallel_ = false&gt; </td></tr>
<tr class="memitem:ac0f1d95625ad9468a29b03c5e3cee0e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesinglepp.html#a3b6460d8cbafda27b6b4a9f5eb969760">RankMatrix</a>&lt; Data, Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinglepp.html#ac0f1d95625ad9468a29b03c5e3cee0e4">load_rankings_from_zlib_buffer</a> (const unsigned char *buffer, size_t len, size_t buffer_size=65536)</td></tr>
<tr class="separator:ac0f1d95625ad9468a29b03c5e3cee0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7853d2074f033573a3074c2cec42d0e"><td class="memTemplParams" colspan="2">template&lt;bool parallel_ = false&gt; </td></tr>
<tr class="memitem:aa7853d2074f033573a3074c2cec42d0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesinglepp.html#ae39cf61993000d182cb3464b4ace1406">Markers</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinglepp.html#aa7853d2074f033573a3074c2cec42d0e">load_markers_from_text_file</a> (const char *path, size_t nfeatures, size_t nlabels, size_t buffer_size=65536)</td></tr>
<tr class="separator:aa7853d2074f033573a3074c2cec42d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6802494860feb29abbe873991857b84"><td class="memTemplParams" colspan="2">template&lt;bool parallel_ = false&gt; </td></tr>
<tr class="memitem:ae6802494860feb29abbe873991857b84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesinglepp.html#ae39cf61993000d182cb3464b4ace1406">Markers</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinglepp.html#ae6802494860feb29abbe873991857b84">load_markers_from_gzip_file</a> (const char *path, size_t nfeatures, size_t nlabels, size_t buffer_size=65536)</td></tr>
<tr class="separator:ae6802494860feb29abbe873991857b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b52377d9b6d6bb1a8db2070c343e8f"><td class="memTemplParams" colspan="2">template&lt;bool parallel_ = false&gt; </td></tr>
<tr class="memitem:ae5b52377d9b6d6bb1a8db2070c343e8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesinglepp.html#ae39cf61993000d182cb3464b4ace1406">Markers</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesinglepp.html#ae5b52377d9b6d6bb1a8db2070c343e8f">load_markers_from_zlib_buffer</a> (const unsigned char *buffer, size_t len, size_t nfeatures, size_t nlabels, size_t buffer_size=65536)</td></tr>
<tr class="separator:ae5b52377d9b6d6bb1a8db2070c343e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Cell type classification using the SingleR algorithm in C++. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ae39cf61993000d182cb3464b4ace1406" name="ae39cf61993000d182cb3464b4ace1406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39cf61993000d182cb3464b4ace1406">&#9670;&#160;</a></span>Markers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;std::vector&lt;std::vector&lt;int&gt; &gt; &gt; <a class="el" href="namespacesinglepp.html#ae39cf61993000d182cb3464b4ace1406">singlepp::Markers</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A vector of vectors of ranked marker lists, used to determine which features should be used to compute correlations in <code><a class="el" href="classsinglepp_1_1Classifier.html" title="Automatically assign cell type labels based on an expression matrix.">Classifier</a></code>.</p>
<p>For a <code>Markers</code> object <code>markers</code>, let us consider the vector at <code>markers[0][1]</code>. This vector is expected to contain the ranked indices of the marker genes for label 0 compared to label 1. Most typically, this is generated by identifying the genes that are upregulated in label 0 compared to 1 and sorting by decreasing effect size. Indices should refer to the rows of the reference expression matrices (i.e., <code>ref</code> in the various <code><a class="el" href="classsinglepp_1_1Classifier.html#ac9820063ea590a345ca82bb6919289d6">Classifier::run()</a></code> or <code><a class="el" href="classsinglepp_1_1BasicBuilder.html#a3a482bb20652991e23596520b1a0de1f">BasicBuilder::run()</a></code> methods). So, for example, <code>markers[0][1][0]</code> should contain the row index of the most upregulated gene in label 0 compared to 1.</p>
<p>For a given reference dataset, the corresponding <code>Markers</code> object should have length equal to the number of labels in that reference. Each middle vector (i.e., <code>markers[i]</code> for non-negative <code>i</code> less than the number of labels) should also have length equal to the number of labels. The innermost vectors that are not on the diagonal (i.e., <code>markers[i][j]</code> for <code>i != j</code>) may be of any positive length and should contain unique row indices. Any innermost vector along the "diagonal" (i.e., <code>markers[i][i]</code>) is typically of zero length.</p>
<p>Ideally, the non-diagonal innermost vectors should be at least as long as the setting of <code><a class="el" href="classsinglepp_1_1Classifier.html#a5406afbfe172ec57062f803d26c45f83">Classifier::set_top()</a></code>. The cell type annotation will still work with shorter (non-empty) vectors but it will not be possible to achieve the user-specified <code>set_top()</code>. In cases involving feature intersections in <code>run()</code>, the vectors should be long enough to achieve the specified <code>set_top()</code> after removing non-shared genes. For longer vectors, the annotation will safely ignore the indices after the <code>set_top()</code> specification.</p>
<p>As mentioned previously, the diagonal innermost vectors are typically empty, given that it makes little sense to identify upregulated markers in a label compared to itself. That said, any genes stored on the diagonal will be respected and used in all feature subsets for the corresponding label. This can be exploited by advanced users to efficiently store "universal" markers for a label, i.e., markers that are applicable in all comparisons to other labels. </p>

</div>
</div>
<a id="a3b6460d8cbafda27b6b4a9f5eb969760" name="a3b6460d8cbafda27b6b4a9f5eb969760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6460d8cbafda27b6b4a9f5eb969760">&#9670;&#160;</a></span>RankMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Data  = double, typename Index  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesinglepp.html#a3b6460d8cbafda27b6b4a9f5eb969760">singlepp::RankMatrix</a> = typedef tatami::DenseColumnMatrix&lt;Data, Index, std::vector&lt;int&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix of ranks as a dense column-major matrix. Each column corresponds to a sample while each row corresponds to a feature. Each column contains the ranked expression values for all features.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Data</td><td>Numeric type for data in the matrix interface. </td></tr>
    <tr><td class="paramname">Index</td><td>Integer type for indices in the matrix interface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a586796abc2b9fee9a5e6164e2a941a0c" name="a586796abc2b9fee9a5e6164e2a941a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586796abc2b9fee9a5e6164e2a941a0c">&#9670;&#160;</a></span>load_features_from_gzip_file()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool parallel_ = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::string &gt;, std::vector&lt; std::string &gt; &gt; singlepp::load_features_from_gzip_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>65536</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">parallel_</td><td>Whether file loading and parsing should be parallelized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a Gzip-compressed file containing the feature annotation. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>Size of the buffer to use when reading the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of vectors, each of length equal to the number of features. The first contains Ensembl IDs while the second contains gene symbols.</dd></dl>
<p>See <code><a class="el" href="namespacesinglepp.html#ad39179283e07be40a5682e295bd8ffa8">load_features_from_text_file()</a></code> for details about the format. </p>

</div>
</div>
<a id="ad39179283e07be40a5682e295bd8ffa8" name="ad39179283e07be40a5682e295bd8ffa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39179283e07be40a5682e295bd8ffa8">&#9670;&#160;</a></span>load_features_from_text_file()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool parallel_ = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::string &gt;, std::vector&lt; std::string &gt; &gt; singlepp::load_features_from_text_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>65536</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">parallel_</td><td>Whether file loading and parsing should be parallelized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a text file containing the feature annotation. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>Size of the buffer to use when reading the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of vectors, each of length equal to the number of features. The first contains Ensembl IDs while the second contains gene symbols.</dd></dl>
<p>The file should contain one line per feature, with total number of lines equal to the number of features in the dataset. Each line should contain two strings separated by a comma. The first string should be the Ensembl ID while the second string should be the gene symbol; either string may be empty. The file should not contain any header. </p>

</div>
</div>
<a id="a49896d2aadb5a23391a38ac2aee4436e" name="a49896d2aadb5a23391a38ac2aee4436e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49896d2aadb5a23391a38ac2aee4436e">&#9670;&#160;</a></span>load_features_from_zlib_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool parallel_ = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::string &gt;, std::vector&lt; std::string &gt; &gt; singlepp::load_features_from_zlib_buffer </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>65536</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">parallel_</td><td>Whether file loading and parsing should be parallelized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to an array containing a Zlib/Gzip-compressed string containing the feature annotation. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">len</td><td>Length of the array for <code>buffer</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer_size</td><td>Size of the buffer to use when decompressing the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of vectors, each of length equal to the number of features. The first contains Ensembl IDs while the second contains gene symbols.</dd></dl>
<p>See <code><a class="el" href="namespacesinglepp.html#ad39179283e07be40a5682e295bd8ffa8">load_features_from_text_file()</a></code> for details about the format. </p>

</div>
</div>
<a id="a11981bf2415263c3af3537aa715f530f" name="a11981bf2415263c3af3537aa715f530f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11981bf2415263c3af3537aa715f530f">&#9670;&#160;</a></span>load_label_names_from_gzip_file()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool parallel_ = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; singlepp::load_label_names_from_gzip_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>65536</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">parallel_</td><td>Whether file loading and parsing should be parallelized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a Gzip-compressed file containing the label names. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>Size of the buffer to use when reading the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of strings containing the name for each label.</dd></dl>
<p>See <code><a class="el" href="namespacesinglepp.html#aa77a7375b1acb5785ae37080297ece71">load_label_names_from_text_file()</a></code> for details about the format. </p>

</div>
</div>
<a id="aa77a7375b1acb5785ae37080297ece71" name="aa77a7375b1acb5785ae37080297ece71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77a7375b1acb5785ae37080297ece71">&#9670;&#160;</a></span>load_label_names_from_text_file()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool parallel_ = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; singlepp::load_label_names_from_text_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>65536</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">parallel_</td><td>Whether file loading and parsing should be parallelized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a text file containing the label names. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>Size of the buffer to use when reading the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of strings containing the name for each reference profile.</dd></dl>
<p>The file should contain one line per label, containing a (non-quoted) string with the full name for that label. The total number of lines should be equal to the number of unique labels in the dataset. The file should not contain any header. </p>

</div>
</div>
<a id="ae0a79b526b73debbf3de4931e4ca9d2e" name="ae0a79b526b73debbf3de4931e4ca9d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a79b526b73debbf3de4931e4ca9d2e">&#9670;&#160;</a></span>load_label_names_from_zlib_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool parallel_ = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; singlepp::load_label_names_from_zlib_buffer </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>65536</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">parallel_</td><td>Whether file loading and parsing should be parallelized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to an array containing a Zlib/Gzip-compressed string of label names. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">len</td><td>Length of the array for <code>buffer</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer_size</td><td>Size of the buffer to use when decompressing the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of strings containing the name for each label.</dd></dl>
<p>See <code><a class="el" href="namespacesinglepp.html#aa77a7375b1acb5785ae37080297ece71">load_label_names_from_text_file()</a></code> for details about the format. </p>

</div>
</div>
<a id="a58095c8ccda647564410c6ee33bad6f1" name="a58095c8ccda647564410c6ee33bad6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58095c8ccda647564410c6ee33bad6f1">&#9670;&#160;</a></span>load_labels_from_gzip_file()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool parallel_ = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; singlepp::load_labels_from_gzip_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>65536</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">parallel_</td><td>Whether file loading and parsing should be parallelized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a Gzip-compressed file containing the labels. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>Size of the buffer to use when reading the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector containing the label index for each reference profile.</dd></dl>
<p>See <code><a class="el" href="namespacesinglepp.html#ac9e38562b296cc7c7d7682f194514634">load_labels_from_text_file()</a></code> for details about the format. </p>

</div>
</div>
<a id="ac9e38562b296cc7c7d7682f194514634" name="ac9e38562b296cc7c7d7682f194514634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e38562b296cc7c7d7682f194514634">&#9670;&#160;</a></span>load_labels_from_text_file()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool parallel_ = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; singlepp::load_labels_from_text_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>65536</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">parallel_</td><td>Whether file loading and parsing should be parallelized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a text file containing the labels. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>Size of the buffer to use when reading the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector containing the label index for each reference profile.</dd></dl>
<p>The file should contain one line per profile, containing an integer label index for that profile. Label indices refer to another array containing the actual names of the labels. The total number of lines should be equal to the number of profiles in the dataset. The file should not contain any header. </p>

</div>
</div>
<a id="a74c5cb9cae30f6db572de03a143c9e06" name="a74c5cb9cae30f6db572de03a143c9e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c5cb9cae30f6db572de03a143c9e06">&#9670;&#160;</a></span>load_labels_from_zlib_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool parallel_ = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; singlepp::load_labels_from_zlib_buffer </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>65536</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">parallel_</td><td>Whether file loading and parsing should be parallelized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to an array containing a Zlib/Gzip-compressed string of labels. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">len</td><td>Length of the array for <code>buffer</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer_size</td><td>Size of the buffer to use when decompressing the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector containing the label index for each reference profile.</dd></dl>
<p>See <code><a class="el" href="namespacesinglepp.html#ac9e38562b296cc7c7d7682f194514634">load_labels_from_text_file()</a></code> for details about the format. </p>

</div>
</div>
<a id="ae6802494860feb29abbe873991857b84" name="ae6802494860feb29abbe873991857b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6802494860feb29abbe873991857b84">&#9670;&#160;</a></span>load_markers_from_gzip_file()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool parallel_ = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesinglepp.html#ae39cf61993000d182cb3464b4ace1406">Markers</a> singlepp::load_markers_from_gzip_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nfeatures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nlabels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>65536</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">parallel_</td><td>Whether file loading and parsing should be parallelized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a Gzip-compressed file containing the marker lists. </td></tr>
    <tr><td class="paramname">nfeatures</td><td>Total number of features in the dataset. </td></tr>
    <tr><td class="paramname">nlabels</td><td>Number of labels in the dataset. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>Size of the buffer to use when reading the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>Markers</code> object containing the markers from each pairwise comparison between labels.</dd></dl>
<p>See <code><a class="el" href="namespacesinglepp.html#aa7853d2074f033573a3074c2cec42d0e">load_markers_from_text_file()</a></code> for details about the format. </p>

</div>
</div>
<a id="aa7853d2074f033573a3074c2cec42d0e" name="aa7853d2074f033573a3074c2cec42d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7853d2074f033573a3074c2cec42d0e">&#9670;&#160;</a></span>load_markers_from_text_file()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool parallel_ = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesinglepp.html#ae39cf61993000d182cb3464b4ace1406">Markers</a> singlepp::load_markers_from_text_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nfeatures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nlabels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>65536</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">parallel_</td><td>Whether file loading and parsing should be parallelized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a text file containing the marker lists. </td></tr>
    <tr><td class="paramname">nfeatures</td><td>Total number of features in the dataset. </td></tr>
    <tr><td class="paramname">nlabels</td><td>Number of labels in the dataset. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>Size of the buffer to use when reading the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>Markers</code> object containing the markers from each pairwise comparison between labels.</dd></dl>
<p>The file should contain one line per pairwise comparison between labels. Each line should at least 3 tab-delimited fields - the index of the first label, the index of the second label, and then the indices of the features selected as marker genes for the first label relative to the second. Any (non-zero) number of marker indices may be reported provided they are ordered by marker strength. The total number of lines in this file should be equal to the total number of pairwise comparisons between different labels, including permutations. </p>

</div>
</div>
<a id="ae5b52377d9b6d6bb1a8db2070c343e8f" name="ae5b52377d9b6d6bb1a8db2070c343e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b52377d9b6d6bb1a8db2070c343e8f">&#9670;&#160;</a></span>load_markers_from_zlib_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool parallel_ = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesinglepp.html#ae39cf61993000d182cb3464b4ace1406">Markers</a> singlepp::load_markers_from_zlib_buffer </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nfeatures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nlabels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>65536</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">parallel_</td><td>Whether file loading and parsing should be parallelized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to an array containing a Zlib/Gzip-compressed string containing the marker lists. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">len</td><td>Length of the array for <code>buffer</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nfeatures</td><td>Total number of features in the dataset. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nlabels</td><td>Number of labels in the dataset. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer_size</td><td>Size of the buffer to use when reading the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>Markers</code> object containing the markers from each pairwise comparison between labels.</dd></dl>
<p>See <code><a class="el" href="namespacesinglepp.html#aa7853d2074f033573a3074c2cec42d0e">load_markers_from_text_file()</a></code> for details about the format. </p>

</div>
</div>
<a id="a7e53df2a196132201f5de886c066959c" name="a7e53df2a196132201f5de886c066959c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e53df2a196132201f5de886c066959c">&#9670;&#160;</a></span>load_rankings_from_gzip_file()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Data  = double, typename Index  = int, bool parallel_ = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesinglepp.html#a3b6460d8cbafda27b6b4a9f5eb969760">RankMatrix</a>&lt; Data, Index &gt; singlepp::load_rankings_from_gzip_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>65536</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Data</td><td>Numeric type for data in the matrix interface. </td></tr>
    <tr><td class="paramname">Index</td><td>Integer type for indices in the matrix interface. </td></tr>
    <tr><td class="paramname">parallel_</td><td>Whether file loading and parsing should be parallelized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a Gzip-compressed file containing the ranking matrix. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>Size of the buffer to use when reading the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>RankMatrix</code> containing the feature rankings for each reference profile. Each column corresponds to a reference profile while each row corresponds to a feature.</dd></dl>
<p>See <code><a class="el" href="namespacesinglepp.html#a01271d95d083bd7d3f1c3b26e9febe18">load_rankings_from_text_file()</a></code> for details about the format. </p>

</div>
</div>
<a id="a01271d95d083bd7d3f1c3b26e9febe18" name="a01271d95d083bd7d3f1c3b26e9febe18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01271d95d083bd7d3f1c3b26e9febe18">&#9670;&#160;</a></span>load_rankings_from_text_file()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Data  = double, typename Index  = int, bool parallel_ = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesinglepp.html#a3b6460d8cbafda27b6b4a9f5eb969760">RankMatrix</a>&lt; Data, Index &gt; singlepp::load_rankings_from_text_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>65536</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Data</td><td>Numeric type for data in the matrix interface. </td></tr>
    <tr><td class="paramname">Index</td><td>Integer type for indices in the matrix interface. </td></tr>
    <tr><td class="paramname">parallel_</td><td>Whether file loading and parsing should be parallelized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a text file containing the ranking matrix. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>Size of the buffer to use when reading the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>RankMatrix</code> containing the feature rankings for each reference profile. Each column corresponds to a reference profile while each row corresponds to a feature.</dd></dl>
<p>The file should contain one line per reference profile, with the total number of lines equal to the number of profiles in the dataset. Each line should contain the rank of each feature's expression within that profile, separated by commas. The number of comma-separated fields on each line should be equal to the number of features. Ranks should be strictly integer - tied ranks should default to the minimum rank among the index set of ties. </p>

</div>
</div>
<a id="ac0f1d95625ad9468a29b03c5e3cee0e4" name="ac0f1d95625ad9468a29b03c5e3cee0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f1d95625ad9468a29b03c5e3cee0e4">&#9670;&#160;</a></span>load_rankings_from_zlib_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Data  = double, typename Index  = int, bool parallel_ = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesinglepp.html#a3b6460d8cbafda27b6b4a9f5eb969760">RankMatrix</a>&lt; Data, Index &gt; singlepp::load_rankings_from_zlib_buffer </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>65536</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Data</td><td>Numeric type for data in the matrix interface. </td></tr>
    <tr><td class="paramname">Index</td><td>Integer type for indices in the matrix interface. </td></tr>
    <tr><td class="paramname">parallel_</td><td>Whether file loading and parsing should be parallelized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to an array containing a Zlib/Gzip-compressed string containing the ranking matrix. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">len</td><td>Length of the array for <code>buffer</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer_size</td><td>Size of the buffer to use when reading the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>RankMatrix</code> containing the feature rankings for each reference profile. Each column corresponds to a reference profile while each row corresponds to a feature.</dd></dl>
<p>See <code><a class="el" href="namespacesinglepp.html#a01271d95d083bd7d3f1c3b26e9febe18">load_rankings_from_text_file()</a></code> for details about the format. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
