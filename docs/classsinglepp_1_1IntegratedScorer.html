<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>singlepp: singlepp::IntegratedScorer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">singlepp
   </div>
   <div id="projectbrief">A C++ library for cell type classification</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesinglepp.html">singlepp</a></li><li class="navelem"><a class="el" href="classsinglepp_1_1IntegratedScorer.html">IntegratedScorer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsinglepp_1_1IntegratedScorer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">singlepp::IntegratedScorer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Integrate classifications from multiple references.  
 <a href="classsinglepp_1_1IntegratedScorer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="IntegratedScorer_8hpp_source.html">IntegratedScorer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsinglepp_1_1IntegratedScorer_1_1Defaults.html">Defaults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parameters.  <a href="structsinglepp_1_1IntegratedScorer_1_1Defaults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsinglepp_1_1IntegratedScorer_1_1Results.html">Results</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structsinglepp_1_1IntegratedScorer_1_1Results.html" title="Results of the integrated annotation.">Results</a> of the integrated annotation.  <a href="structsinglepp_1_1IntegratedScorer_1_1Results.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6c6636928a00394e858f3be701db9bee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsinglepp_1_1IntegratedScorer.html">IntegratedScorer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1IntegratedScorer.html#a6c6636928a00394e858f3be701db9bee">set_quantile</a> (double q=<a class="el" href="structsinglepp_1_1IntegratedScorer_1_1Defaults.html#a1058e4961997fdeb6726f064261248e6">Defaults::quantile</a>)</td></tr>
<tr class="separator:a6c6636928a00394e858f3be701db9bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616be74bb3f7de8b91748309b2946a5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsinglepp_1_1IntegratedScorer.html">IntegratedScorer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1IntegratedScorer.html#a616be74bb3f7de8b91748309b2946a5f">set_num_threads</a> (int n=<a class="el" href="structsinglepp_1_1IntegratedScorer_1_1Defaults.html#a7a85157f514e497ecf23c147e939a2da">Defaults::num_threads</a>)</td></tr>
<tr class="separator:a616be74bb3f7de8b91748309b2946a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea67add3480038327b1d0280924e275"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1IntegratedScorer.html#a9ea67add3480038327b1d0280924e275">run</a> (const tatami::Matrix&lt; double, int &gt; *mat, const std::vector&lt; const int * &gt; &amp;assigned, const std::vector&lt; <a class="el" href="structsinglepp_1_1IntegratedReference.html">IntegratedReference</a> &gt; &amp;references, int *best, std::vector&lt; double * &gt; &amp;scores, double *delta) const</td></tr>
<tr class="separator:a9ea67add3480038327b1d0280924e275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453ac192a21743bec5121c7b5dd670c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsinglepp_1_1IntegratedScorer_1_1Results.html">Results</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1IntegratedScorer.html#a453ac192a21743bec5121c7b5dd670c6">run</a> (const tatami::Matrix&lt; double, int &gt; *mat, const std::vector&lt; const int * &gt; &amp;assigned, const std::vector&lt; <a class="el" href="structsinglepp_1_1IntegratedReference.html">IntegratedReference</a> &gt; &amp;references) const</td></tr>
<tr class="separator:a453ac192a21743bec5121c7b5dd670c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Integrate classifications from multiple references. </p>
<p >In situations where multiple reference datasets are available, we would like to obtain a single prediction for each cell from all of those references. This is somewhat tricky as the different references are likely to contain strong batch effects, complicating the calculation of marker genes between labels from different references (and thus precluding direct use of the usual <code><a class="el" href="classsinglepp_1_1Classifier.html#ac9820063ea590a345ca82bb6919289d6">Classifier::run()</a></code>). The labels themselves also tend to be inconsistent, e.g., different vocabularies and resolutions, making it difficult to define sensible groups in a combined "super-reference".</p>
<p >To avoid these issues, we first perform classification within each reference individually. For each test cell, we identify its predicted label from a given reference, and we collect all the marker genes for that label (across all pairwise comparisons in that reference). After doing this for each reference, we pool all of the collected markers to obtain a common set of interesting genes. We then compute the correlation-based score between the test cell's expression profile and its predicted label from each reference, using that common set of genes. The label with the highest score is considered the best representative across all references.</p>
<p >This strategy is similar to using <code><a class="el" href="classsinglepp_1_1Classifier.html#ac9820063ea590a345ca82bb6919289d6">Classifier::run()</a></code> without fine-tuning, except that we are choosing between the best labels from all references rather than between all labels from one reference. The main idea is to create a common feature set so that the correlations can be reasonably compared across references. Note that differences in the feature sets across references are tolerated by simply ignoring missing genes when computing the correlations. This reduces the comparability of the scores as the effective feature set will vary a little (or a lot, depending) across references; nonetheless, it is preferred to taking the intersection, which is liable to leave us with very few genes.</p>
<p >Our approach avoids any direct comparison between the expression profiles of different references, allowing us to side-step the question of how to deal with the batch effects. Similarly, we defer responsibility on solving the issue of label heterogeneity, by just passing along the existing labels and leaving it to the user's interpretation. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a453ac192a21743bec5121c7b5dd670c6" name="a453ac192a21743bec5121c7b5dd670c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453ac192a21743bec5121c7b5dd670c6">&#9670;&nbsp;</a></span>run() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsinglepp_1_1IntegratedScorer_1_1Results.html">Results</a> singlepp::IntegratedScorer::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; double, int &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const int * &gt; &amp;&#160;</td>
          <td class="paramname"><em>assigned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structsinglepp_1_1IntegratedReference.html">IntegratedReference</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>references</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mat</td><td>Expression matrix of the test dataset, where rows are genes and columns are cells. The identity of the rows should be consistent with the arguments used in <code><a class="el" href="classsinglepp_1_1IntegratedBuilder.html#a7f3c49224a66c3e9ed5bdd1c140f03aa">IntegratedBuilder::add()</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">assigned</td><td>Vector of pointers of length equal to the number of references. Each pointer should point to an array of length equal to the number of columns in <code>mat</code>, containing the assigned label for each column in each reference. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">references</td><td>Vector of integrated references produced by <code><a class="el" href="classsinglepp_1_1IntegratedBuilder.html#a980f86775bcb3de1f7d9ed24a1f3458b">IntegratedBuilder::finish()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structsinglepp_1_1IntegratedScorer_1_1Results.html" title="Results of the integrated annotation.">Results</a></code> object containing the assigned labels and scores. </dd></dl>

</div>
</div>
<a id="a9ea67add3480038327b1d0280924e275" name="a9ea67add3480038327b1d0280924e275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea67add3480038327b1d0280924e275">&#9670;&nbsp;</a></span>run() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void singlepp::IntegratedScorer::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; double, int &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const int * &gt; &amp;&#160;</td>
          <td class="paramname"><em>assigned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structsinglepp_1_1IntegratedReference.html">IntegratedReference</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>references</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>best</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double * &gt; &amp;&#160;</td>
          <td class="paramname"><em>scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mat</td><td>Expression matrix of the test dataset, where rows are genes and columns are cells. The identity of the rows should be consistent with the arguments used in <code><a class="el" href="classsinglepp_1_1IntegratedBuilder.html#a7f3c49224a66c3e9ed5bdd1c140f03aa">IntegratedBuilder::add()</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">assigned</td><td>Vector of pointers of length equal to the number of references. Each pointer should point to an array of length equal to the number of columns in <code>mat</code>, containing the assigned label for each column in each reference. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">references</td><td>Vector of integrated references produced by <code><a class="el" href="classsinglepp_1_1IntegratedBuilder.html#a980f86775bcb3de1f7d9ed24a1f3458b">IntegratedBuilder::finish()</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">best</td><td>Pointer to an array of length equal to the number of columns in <code>mat</code>. This is filled with the index of the reference with the best label for each cell. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">scores</td><td>Vector of pointers of length equal to the number of references. Each pointer should point to an array of length equal to the number of columns in <code>mat</code>. This is filled with the (non-fine-tuned) score for the best label of that reference for each cell. Any pointer may be <code>NULL</code> in which case the scores for that label will not be saved. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">delta</td><td>Pointer to an array of length equal to the number of columns in <code>mat</code>. This is filled with the difference between the highest and second-highest scores. This may also be <code>NULL</code> in which case the deltas are not reported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>best</code>, <code>scores</code> and <code>delta</code> are filled with their output values. </dd></dl>

</div>
</div>
<a id="a616be74bb3f7de8b91748309b2946a5f" name="a616be74bb3f7de8b91748309b2946a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616be74bb3f7de8b91748309b2946a5f">&#9670;&nbsp;</a></span>set_num_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinglepp_1_1IntegratedScorer.html">IntegratedScorer</a> &amp; singlepp::IntegratedScorer::set_num_threads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structsinglepp_1_1IntegratedScorer_1_1Defaults.html#a7a85157f514e497ecf23c147e939a2da">Defaults::num_threads</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of threads to use. By default, this is inherited from the parent <code><a class="el" href="classsinglepp_1_1IntegratedBuilder.html" title="Factory to prepare multiple references for integrated classification.">IntegratedBuilder</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classsinglepp_1_1IntegratedScorer.html" title="Integrate classifications from multiple references.">IntegratedScorer</a></code> object. </dd></dl>

</div>
</div>
<a id="a6c6636928a00394e858f3be701db9bee" name="a6c6636928a00394e858f3be701db9bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6636928a00394e858f3be701db9bee">&#9670;&nbsp;</a></span>set_quantile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinglepp_1_1IntegratedScorer.html">IntegratedScorer</a> &amp; singlepp::IntegratedScorer::set_quantile </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="structsinglepp_1_1IntegratedScorer_1_1Defaults.html#a1058e4961997fdeb6726f064261248e6">Defaults::quantile</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Quantile to use to compute a per-label score from the correlations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classsinglepp_1_1IntegratedScorer.html" title="Integrate classifications from multiple references.">IntegratedScorer</a></code> object.</dd></dl>
<p>See <code><a class="el" href="classsinglepp_1_1Classifier.html#a8da2466b32076a34b038d0bb88282ae1">Classifier::set_quantile()</a></code> for more details. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>singlepp/<a class="el" href="IntegratedScorer_8hpp_source.html">IntegratedScorer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
