<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>singlepp: singlepp::BasicScorer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">singlepp
   </div>
   <div id="projectbrief">A C++ library for cell type classification</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesinglepp.html">singlepp</a></li><li class="navelem"><a class="el" href="classsinglepp_1_1BasicScorer.html">BasicScorer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsinglepp_1_1BasicScorer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">singlepp::BasicScorer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Classify cells from a single pre-built reference dataset.  
 <a href="classsinglepp_1_1BasicScorer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BasicScorer_8hpp_source.html">BasicScorer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsinglepp_1_1BasicScorer_1_1Defaults.html">Defaults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parameters for classification.  <a href="structsinglepp_1_1BasicScorer_1_1Defaults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsinglepp_1_1BasicScorer_1_1Results.html">Results</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automated classification results.  <a href="structsinglepp_1_1BasicScorer_1_1Results.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2181e5fb75b36d277fcd359a1cf89ee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsinglepp_1_1BasicScorer.html">BasicScorer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1BasicScorer.html#a2181e5fb75b36d277fcd359a1cf89ee7">set_quantile</a> (double q=<a class="el" href="structsinglepp_1_1BasicScorer_1_1Defaults.html#a3b4a0f29885d3ec090c3a104a33a9aac">Defaults::quantile</a>)</td></tr>
<tr class="separator:a2181e5fb75b36d277fcd359a1cf89ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bf5e2dad193fcb36bfece13bc35c03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsinglepp_1_1BasicScorer.html">BasicScorer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1BasicScorer.html#a63bf5e2dad193fcb36bfece13bc35c03">set_fine_tune_threshold</a> (double t=<a class="el" href="structsinglepp_1_1BasicScorer_1_1Defaults.html#a6427234a728e0d54f8d5547bb95377ca">Defaults::fine_tune_threshold</a>)</td></tr>
<tr class="separator:a63bf5e2dad193fcb36bfece13bc35c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede57b2a0876ae9e3fe020e26128f7c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsinglepp_1_1BasicScorer.html">BasicScorer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1BasicScorer.html#aede57b2a0876ae9e3fe020e26128f7c7">set_fine_tune</a> (bool f=<a class="el" href="structsinglepp_1_1BasicScorer_1_1Defaults.html#ac9c5fe9a72649b3b3c01010c1b8367b2">Defaults::fine_tune</a>)</td></tr>
<tr class="separator:aede57b2a0876ae9e3fe020e26128f7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa594e9db4ce5dc54f2508f7cf8c7b0f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsinglepp_1_1BasicScorer.html">BasicScorer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1BasicScorer.html#aa594e9db4ce5dc54f2508f7cf8c7b0f3">set_num_threads</a> (int n=<a class="el" href="structsinglepp_1_1BasicScorer_1_1Defaults.html#a31a145b0bfde66e97cdb9bfbfe787277">Defaults::num_threads</a>)</td></tr>
<tr class="separator:aa594e9db4ce5dc54f2508f7cf8c7b0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988f7cebb10373c6382ad052124138dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1BasicScorer.html#a988f7cebb10373c6382ad052124138dc">run</a> (const tatami::Matrix&lt; double, int &gt; *mat, const <a class="el" href="structsinglepp_1_1BasicBuilder_1_1Prebuilt.html">BasicBuilder::Prebuilt</a> &amp;built, const int *mat_subset, int *best, std::vector&lt; double * &gt; &amp;scores, double *delta) const</td></tr>
<tr class="separator:a988f7cebb10373c6382ad052124138dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70d48b3f476c63b498d5cb438054a37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1BasicScorer.html#aa70d48b3f476c63b498d5cb438054a37">run</a> (const tatami::Matrix&lt; double, int &gt; *mat, const <a class="el" href="structsinglepp_1_1BasicBuilder_1_1Prebuilt.html">BasicBuilder::Prebuilt</a> &amp;built, int *best, std::vector&lt; double * &gt; &amp;scores, double *delta) const</td></tr>
<tr class="separator:aa70d48b3f476c63b498d5cb438054a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7138d0166dc85491953faea121154d70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsinglepp_1_1BasicScorer_1_1Results.html">Results</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1BasicScorer.html#a7138d0166dc85491953faea121154d70">run</a> (const tatami::Matrix&lt; double, int &gt; *mat, const <a class="el" href="structsinglepp_1_1BasicBuilder_1_1Prebuilt.html">BasicBuilder::Prebuilt</a> &amp;built) const</td></tr>
<tr class="separator:a7138d0166dc85491953faea121154d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c801f0908d4614a0a51a01e1816551"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsinglepp_1_1BasicScorer_1_1Results.html">Results</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1BasicScorer.html#ac0c801f0908d4614a0a51a01e1816551">run</a> (const tatami::Matrix&lt; double, int &gt; *mat, const <a class="el" href="structsinglepp_1_1BasicBuilder_1_1Prebuilt.html">BasicBuilder::Prebuilt</a> &amp;built, const int *mat_subset) const</td></tr>
<tr class="separator:ac0c801f0908d4614a0a51a01e1816551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cd68f7b1df0c113553b9baf2d0fff6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1BasicScorer.html#ab1cd68f7b1df0c113553b9baf2d0fff6">run</a> (const tatami::Matrix&lt; double, int &gt; *mat, const <a class="el" href="structsinglepp_1_1BasicBuilder_1_1PrebuiltIntersection.html">BasicBuilder::PrebuiltIntersection</a> &amp;built, int *best, std::vector&lt; double * &gt; &amp;scores, double *delta) const</td></tr>
<tr class="separator:ab1cd68f7b1df0c113553b9baf2d0fff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2541bceababa26c24beb95ef08f5c0e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsinglepp_1_1BasicScorer_1_1Results.html">Results</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1BasicScorer.html#a2541bceababa26c24beb95ef08f5c0e7">run</a> (const tatami::Matrix&lt; double, int &gt; *mat, const <a class="el" href="structsinglepp_1_1BasicBuilder_1_1PrebuiltIntersection.html">BasicBuilder::PrebuiltIntersection</a> &amp;built) const</td></tr>
<tr class="separator:a2541bceababa26c24beb95ef08f5c0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Classify cells from a single pre-built reference dataset. </p>
<p>This class uses the pre-built reference from <code><a class="el" href="classsinglepp_1_1BasicBuilder.html" title="Construct a single pre-built reference for further classification.">BasicBuilder</a></code> to classify each cell in a test dataset. The algorithm and parameters are the same as described for the <code><a class="el" href="classsinglepp_1_1Classifier.html" title="Automatically assign cell type labels based on an expression matrix.">Classifier</a></code> class; in fact, <code><a class="el" href="classsinglepp_1_1Classifier.html" title="Automatically assign cell type labels based on an expression matrix.">Classifier</a></code> just calls <code><a class="el" href="classsinglepp_1_1BasicBuilder.html#a3a482bb20652991e23596520b1a0de1f">BasicBuilder::run()</a></code> and then <code><a class="el" href="classsinglepp_1_1BasicScorer.html#a988f7cebb10373c6382ad052124138dc">BasicScorer::run()</a></code>.</p>
<p>It is occasionally useful to call these two functions separately if the same reference dataset is to be used multiple times, e.g., on different test datasets or with different parameters. In such cases, we can save time by avoiding redundant builds; we just have to call <code><a class="el" href="classsinglepp_1_1BasicScorer.html#a988f7cebb10373c6382ad052124138dc">BasicScorer::run()</a></code> in all subsequent uses of the pre-built reference. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a7138d0166dc85491953faea121154d70" name="a7138d0166dc85491953faea121154d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7138d0166dc85491953faea121154d70">&#9670;&#160;</a></span>run() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsinglepp_1_1BasicScorer_1_1Results.html">Results</a> singlepp::BasicScorer::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; double, int &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsinglepp_1_1BasicBuilder_1_1Prebuilt.html">BasicBuilder::Prebuilt</a> &amp;&#160;</td>
          <td class="paramname"><em>built</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Expression matrix of the test dataset, where rows are genes and columns are cells. Each row should correspond to an element of <code>Prebuilt::subset</code>. </td></tr>
    <tr><td class="paramname">built</td><td>An object produced by <code>BasicBuilder::build()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structsinglepp_1_1BasicScorer_1_1Results.html" title="Automated classification results.">Results</a></code> object containing the assigned labels and scores. </dd></dl>

</div>
</div>
<a id="ac0c801f0908d4614a0a51a01e1816551" name="ac0c801f0908d4614a0a51a01e1816551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c801f0908d4614a0a51a01e1816551">&#9670;&#160;</a></span>run() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsinglepp_1_1BasicScorer_1_1Results.html">Results</a> singlepp::BasicScorer::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; double, int &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsinglepp_1_1BasicBuilder_1_1Prebuilt.html">BasicBuilder::Prebuilt</a> &amp;&#160;</td>
          <td class="paramname"><em>built</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>mat_subset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mat</td><td>Expression matrix of the test dataset, where rows are genes and columns are cells. This may have a different ordering of genes compared to the reference matrix used in <code>build()</code>, provided that all genes corresponding to <code>Prebuilt::subset</code> are present. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">built</td><td>An object produced by <code>BasicBuilder::build()</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_subset</td><td>Pointer to an array of length equal to that of <code>Prebuilt::subset</code>, containing the index of the row of <code>mat</code> corresponding to each gene in <code>Prebuilt::subset</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structsinglepp_1_1BasicScorer_1_1Results.html" title="Automated classification results.">Results</a></code> object containing the assigned labels and scores. </dd></dl>

</div>
</div>
<a id="a988f7cebb10373c6382ad052124138dc" name="a988f7cebb10373c6382ad052124138dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988f7cebb10373c6382ad052124138dc">&#9670;&#160;</a></span>run() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void singlepp::BasicScorer::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; double, int &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsinglepp_1_1BasicBuilder_1_1Prebuilt.html">BasicBuilder::Prebuilt</a> &amp;&#160;</td>
          <td class="paramname"><em>built</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>mat_subset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>best</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double * &gt; &amp;&#160;</td>
          <td class="paramname"><em>scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mat</td><td>Expression matrix of the test dataset, where rows are genes and columns are cells. This may have a different ordering of genes compared to the reference matrix used to create <code>built</code>, provided that all genes corresponding to <code>built.subset</code> are present. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">built</td><td>An object produced by <code>BasicBuilder::build()</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_subset</td><td>Pointer to an array of length equal to that of <code>built.subset</code>, containing the index of the row of <code>mat</code> corresponding to each gene in <code>built.subset</code>. That is, row <code>mat_subset[i]</code> in <code>mat</code> should be the same gene as row <code>built.subset[i]</code> in the reference matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">best</td><td>Pointer to an array of length equal to the number of columns in <code>mat</code>. This is filled with the index of the assigned label for each cell. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">scores</td><td>Vector of pointers to arrays of length equal to the number of columns in <code>mat</code>. This is filled with the (non-fine-tuned) score for each label for each cell. Any pointer may be <code>NULL</code> in which case the scores for that label will not be saved. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">delta</td><td>Pointer to an array of length equal to the number of columns in <code>mat</code>. This is filled with the difference between the highest and second-highest scores, possibly after fine-tuning. This may also be <code>NULL</code> in which case the deltas are not reported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>best</code>, <code>scores</code> and <code>delta</code> are filled with their output values. </dd></dl>

</div>
</div>
<a id="aa70d48b3f476c63b498d5cb438054a37" name="aa70d48b3f476c63b498d5cb438054a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70d48b3f476c63b498d5cb438054a37">&#9670;&#160;</a></span>run() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void singlepp::BasicScorer::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; double, int &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsinglepp_1_1BasicBuilder_1_1Prebuilt.html">BasicBuilder::Prebuilt</a> &amp;&#160;</td>
          <td class="paramname"><em>built</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>best</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double * &gt; &amp;&#160;</td>
          <td class="paramname"><em>scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mat</td><td>Expression matrix of the test dataset, where rows are genes and columns are cells. This should have the same order and identity of genes as the reference matrix used to create <code>built</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">built</td><td>An object produced by <code>BasicBuilder::build()</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">best</td><td>Pointer to an array of length equal to the number of columns in <code>mat</code>. This is filled with the index of the assigned label for each cell. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">scores</td><td>Vector of pointers to arrays of length equal to the number of columns in <code>mat</code>. This is filled with the (non-fine-tuned) score for each label for each cell. Any pointer may be <code>NULL</code> in which case the scores for that label will not be saved. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">delta</td><td>Pointer to an array of length equal to the number of columns in <code>mat</code>. This is filled with the difference between the highest and second-highest scores, possibly after fine-tuning. This may also be <code>NULL</code> in which case the deltas are not reported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>best</code>, <code>scores</code> and <code>delta</code> are filled with their output values. </dd></dl>

</div>
</div>
<a id="a2541bceababa26c24beb95ef08f5c0e7" name="a2541bceababa26c24beb95ef08f5c0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2541bceababa26c24beb95ef08f5c0e7">&#9670;&#160;</a></span>run() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsinglepp_1_1BasicScorer_1_1Results.html">Results</a> singlepp::BasicScorer::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; double, int &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsinglepp_1_1BasicBuilder_1_1PrebuiltIntersection.html">BasicBuilder::PrebuiltIntersection</a> &amp;&#160;</td>
          <td class="paramname"><em>built</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Expression matrix of the test dataset, where rows are genes and columns are cells. </td></tr>
    <tr><td class="paramname">built</td><td>An object produced by <code>build()</code> with intersections.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structsinglepp_1_1BasicScorer_1_1Results.html" title="Automated classification results.">Results</a></code> object containing the assigned labels and scores. </dd></dl>

</div>
</div>
<a id="ab1cd68f7b1df0c113553b9baf2d0fff6" name="ab1cd68f7b1df0c113553b9baf2d0fff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1cd68f7b1df0c113553b9baf2d0fff6">&#9670;&#160;</a></span>run() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void singlepp::BasicScorer::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; double, int &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsinglepp_1_1BasicBuilder_1_1PrebuiltIntersection.html">BasicBuilder::PrebuiltIntersection</a> &amp;&#160;</td>
          <td class="paramname"><em>built</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>best</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double * &gt; &amp;&#160;</td>
          <td class="paramname"><em>scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mat</td><td>Expression matrix of the test dataset, where rows are genes and columns are cells. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">built</td><td>An object produced by <code>build()</code> with intersections. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">best</td><td>Pointer to an array of length equal to the number of columns in <code>mat</code>. This is filled with the index of the assigned label for each cell. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">scores</td><td>Vector of pointers to arrays of length equal to the number of columns in <code>mat</code>. This is filled with the (non-fine-tuned) score for each label for each cell. Any pointer may be <code>NULL</code> in which case the scores for that label will not be saved. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">delta</td><td>Pointer to an array of length equal to the number of columns in <code>mat</code>. This is filled with the difference between the highest and second-highest scores, possibly after fine-tuning. This may also be <code>NULL</code> in which case the deltas are not reported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>best</code>, <code>scores</code> and <code>delta</code> are filled with their output values. </dd></dl>

</div>
</div>
<a id="aede57b2a0876ae9e3fe020e26128f7c7" name="aede57b2a0876ae9e3fe020e26128f7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede57b2a0876ae9e3fe020e26128f7c7">&#9670;&#160;</a></span>set_fine_tune()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinglepp_1_1BasicScorer.html">BasicScorer</a> &amp; singlepp::BasicScorer::set_fine_tune </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="structsinglepp_1_1BasicScorer_1_1Defaults.html#ac9c5fe9a72649b3b3c01010c1b8367b2">Defaults::fine_tune</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Whether to perform fine-tuning, see <code><a class="el" href="classsinglepp_1_1Classifier.html#aed20bfa64b9dd557f38b665116e8005a">Classifier::set_fine_tune()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classsinglepp_1_1BasicScorer.html" title="Classify cells from a single pre-built reference dataset.">BasicScorer</a></code> object. </dd></dl>

</div>
</div>
<a id="a63bf5e2dad193fcb36bfece13bc35c03" name="a63bf5e2dad193fcb36bfece13bc35c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63bf5e2dad193fcb36bfece13bc35c03">&#9670;&#160;</a></span>set_fine_tune_threshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinglepp_1_1BasicScorer.html">BasicScorer</a> &amp; singlepp::BasicScorer::set_fine_tune_threshold </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="structsinglepp_1_1BasicScorer_1_1Defaults.html#a6427234a728e0d54f8d5547bb95377ca">Defaults::fine_tune_threshold</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Threshold to use to select the top-scoring subset of labels during fine-tuning, see <code><a class="el" href="classsinglepp_1_1Classifier.html#a2a5cc599c01248cd5e14508a4b0ec0e5">Classifier::set_fine_tune_threshold()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classsinglepp_1_1BasicScorer.html" title="Classify cells from a single pre-built reference dataset.">BasicScorer</a></code> object. </dd></dl>

</div>
</div>
<a id="aa594e9db4ce5dc54f2508f7cf8c7b0f3" name="aa594e9db4ce5dc54f2508f7cf8c7b0f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa594e9db4ce5dc54f2508f7cf8c7b0f3">&#9670;&#160;</a></span>set_num_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinglepp_1_1BasicScorer.html">BasicScorer</a> &amp; singlepp::BasicScorer::set_num_threads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structsinglepp_1_1BasicScorer_1_1Defaults.html#a31a145b0bfde66e97cdb9bfbfe787277">Defaults::num_threads</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classsinglepp_1_1BasicScorer.html" title="Classify cells from a single pre-built reference dataset.">BasicScorer</a></code> object. </dd></dl>

</div>
</div>
<a id="a2181e5fb75b36d277fcd359a1cf89ee7" name="a2181e5fb75b36d277fcd359a1cf89ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2181e5fb75b36d277fcd359a1cf89ee7">&#9670;&#160;</a></span>set_quantile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinglepp_1_1BasicScorer.html">BasicScorer</a> &amp; singlepp::BasicScorer::set_quantile </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="structsinglepp_1_1BasicScorer_1_1Defaults.html#a3b4a0f29885d3ec090c3a104a33a9aac">Defaults::quantile</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Quantile to use to compute a per-label score from the correlations, see <code><a class="el" href="classsinglepp_1_1Classifier.html#a8da2466b32076a34b038d0bb88282ae1">Classifier::set_quantile()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classsinglepp_1_1BasicScorer.html" title="Classify cells from a single pre-built reference dataset.">BasicScorer</a></code> object. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>singlepp/<a class="el" href="BasicScorer_8hpp_source.html">BasicScorer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
